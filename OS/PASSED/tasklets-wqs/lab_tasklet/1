request_irq - разрешает определенную линию прерываний. 
РЕГИСТРИРУЕТ ОБРАБОТЧИК АППАРАТНОГО ПРЕРЫВАНИЯ НА РАЗДЕЛЯЕМУЮ ЛИНИЮ IRQ
	номер прерывания
	указатель на функцию обработчика прерывания, который обслуживает прерывание
	irqflags - флаги - обычно NULL либо битовая маска
	     IRQF_SHARED - на одну линию прерывания можно зарегистрировать несколько обработчиков.
	dev_name - текст, представляющий имя устройства, связанного с прерыванием
	dev_id - используется для разделения линии прерывания.

	возвращ.значение - 0 - ОК, не 0 - ОШИБКА, E_BUSY - данная линия уже используется и нет 									флага IRQF_SHARED
	
Обработчик прерывания:
	irq - номер линии прерывания, которую он обслуживает
	dev_id - тот же, что и в request_irq, указывает на структуру struct device (?)
	reqs - структура, содержащая регистры процессора и состояние перед обслуживанием прерывания
			(исп для отладки)
	возвращаемое значение - irqreturn_t: IRQ_NONE - обраб. обнаруживает прерывание, которое 							его устройство не инициализировало 
					     IRQ_HANDLER - обраб. прерывания был вызван корректно
							и его устройство действ. вызвало прерывание

Обработчик прерывания делится на две части: 
1. обработчик прерываний
2. выполнение на более низком приоритете

ЗАВЕРШЕНИЕ ОБРАБОТКИ ПРЕРЫВАНИЯ выполняется нижней половиной.

Верхняя половина может выполняться при запрещенных прерываниях и возвращает обычным return
		 должна обеспечить последующее выполнение нижней половины.
В.п. ставит в очерень на выполнение Н.п.

Типы нижних половин:
	отложенные прерывания - soft irq - вып. по возврату из аппаратного прервания
	тасклеты
	очереди работ

---------------------------------------------------------------------------------------------------
Тасклеты - отложенные прерывания, для которых обработчик не может выполняться одновременно на нескольких процессах.
ВЫПОЛНЯЮТСЯ В КОНТЕКСТЕ ПРЕРЫВАНИЯ. Код д.б. неделимым
ВЫПОЛНЯЮТСЯ НА ПРОЦЕССОРЕ, НА КОТОРОМ БЫЛО ВЫПОЛНЕНО АППАРАТНОЕ ПРЕРЫВАНИЕ

М.б. зарегистрированы статически DECLARE_TASKLET(name, func, data) с count = 0
 и динамически с помощью функции tasklet_init(struct tasklet_struct *t,
						void (*func)(unsigned long),
						unsigned long data)

struct tasklet_struct {
	struct tasklet_struct *next,
	unsigned long state, //текущее состояние - TASKLET_STATE_SCHED - запланирован на выполнение
						   TASKLET_STATE_RUN - тасклет выполняется
	atomic_t count, // счетчик ссылок - =0 - тасклет разрешен, может выполняться если ждет вып.
					   !=0 - тасклет ждет и не может выполняться
	void (*func)(unsigned long data), //функция-обработчик тасклета
	unsigned long data
}

В обработчике тасклетов нельзя использовать семафоры, так как тасклеты НЕ МОГУТ переходить в состояние блокировки
Если в тасклете используются общие с обработчиком прерывания или другим тасклетом данные, то доступ д.б. монопольным - с ИСПОЛЬЗОВАНИЕМ СПИНЛОКОВ


ПЛАНИРОВАНИЕ ТАСКЛЕТОВ
Чтобы тасклет начал выполняться его нужно запланировать - поместить в очередь обработчика прервания
tasklet_schedule(struct tasklet_struct *) или tasklet_high_shedule(struct tasklet_struct *)

Запланированные тасклеты хранятся в 2х связных списках:
tasklet_vec и tasklet_hi_vec - высокоприоритетные тасклеты

После того как тасклет был запланирован он будет запущен ТОЛЬКО ОДИН РАЗ даже если он был запланирован на выполнение несколько раз

Определены функции:
	tasklet_enable()
	tasklet_disable()
	tasklet_kill() - ждет пока тасклет завершится затем удаляет его из очереди на выполнение
	tasklet_kill_immediate() - удалит тасклет из очереди в любом случае


ОТЛОЖЕННЫЕ ПРЕРЫВАНИЯ VS ТАСКЛЕТЫ
О.п. используются для запуска самых критичных нижних половин обработчика прерывания
     лучше для задач, критичных по времени выполнения
     обработчик не может переходить в состояние блокировки и 3 обработчика могут выпонляться 		параллельно
Т. имеют простой интерфейс и упрощенные правила блокировок, 2 тасклета одного типа не будут выполняться параллельно
   если нет необходимости масштабировать на бесконечное число процессов
---------------------------------------------------------------------------------------------------
ОЧЕРЕДИ РАБОТ
- выполняются в контексте специального процесса/потока ядра - WORKER
- по умолчанию выполняются на том же процессоре, на котором было выполнено прерывание, но это можно поменять

код ядра может запросить, чтобы выполнение запланированной очереди работ было отложено на определенный интервал времени -> код о.р. не должен быть атомарным

Тип очереди работ - struct workqueue_struct
О.р. должна быть создана до ее использования с помощью функций
		create_workqueue 
		alloc_workqueue
Далее чтобы поместить задачу в очередь работ нужно заполнить структуру struct work_struct
	это делается с помощью макроса INIT_WORK(struct work_struct,
						 void (*func)(void *))
		func - функция, содержащая обработчик нижней половины

В обработчике аппаратного прерывания вызывается функция отправки задания в очередь на выполнение
		queue_work(queue, work)

Чтобы убедиться, что любая запланированная работа завершена вызывается 
		flush_workqueue
	после возврата из этой функции никакая из функций work не будет выполняться нигде в 		системе
Ликвидируется очередь с помощью вызова
	destroy_workqueue

Worker'ы обеспечивают асинхронное исполнение work-ов из очереди. Хотя они вызывают ворки в порядке очереди но так как есть вытеснение сон ожидание, то строгого последовательного выполнения нет. 
worker-ы это потоки ядра, ими управляет основной планировщик ядра.








